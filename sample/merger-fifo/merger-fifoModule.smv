MODULE main

IVAR 
	defineModo : boolean; -- só pode ser usado em next's... perde parte da utilidade

VAR
    time : 0..6;
	--    time : integer; não podemos fazer nada assim porque o modelChecker fica limitado, considerando que BDD não pode ser usado!
    modoEntrada : boolean;
    enumerado: {OCUPADO};
    automata : finalAutomata(time,modoEntrada);

ASSIGN 
    init(time) := 0;
    init(modoEntrada):= FALSE;
							-- não podemos usar input vars porque elas possuem sérias limitações nos assigns
    next(time) := case 
        time = 6 : 0;
        TRUE     : time + 1;
    esac;
    next(modoEntrada) := case
    	next(time) = 2 & defineModo: TRUE;
    	time = 6 : FALSE;
    	TRUE : modoEntrada;
    esac;	

CTLSPEC AG( ( automata.ports.a.value != NULL &  automata.ports.b.value = NULL)
			|(automata.ports.a.value = NULL & automata.ports.b.value != NULL) 
			| (automata.ports.a.value = NULL & automata.ports.b.value = NULL)) ;	    

MODULE portsModule(time,modoEntrada)
VAR
--	a: {0, 1, NULL};
--	b: {0, 1, 4,5,6,7,8, NULL};
--	balt: {1};
--	c: {NULL, 0, 1, 5,7,6,9,8,10, 4};
--	d: {NULL, 0, 1, 5,7,6,9,8,10, 4};
--	invertScopeB : boolean;
	a: tds_a(time);
	b: tds_b(time,modoEntrada);
	c: port_c(time);
	d: port_d(time);
--	c: {NULL, 0, 1};
--	d: {NULL, 0, 1};
ASSIGN

	init(c.value):= case
				a.value = NULL : b.value; 
				b.value = NULL : a.value; 
				TRUE : NULL ;
			esac; 
	init(d.value):= NULL;		
		

	next(c.value):=
			case
				next(a.value) = NULL : next(b.value); 
				next(b.value) = NULL : next(a.value);
				TRUE : NULL ;
			esac;

	next(d.value):= case
				d.value = NULL : c.value;
				c.value = NULL & d.value != NULL : NULL; 
				TRUE : d.value;
			esac;


MODULE tds_a(time)
	VAR
		value: {0, 1, NULL};
	ASSIGN
		
		init(value):= 0;
		next(value):=
			case
				next(time) = 1 : 1;
				next(time) = 2 : 0;
				next(time) = 0 : 0; --reset para valor init
				TRUE : NULL;
			esac;

MODULE tds_b(time,modoEntrada)
	VAR
		value: {0, 1, NULL};
		invert : boolean;
	ASSIGN
		init(invert) := !modoEntrada;
		next(invert) := !next(modoEntrada);

		init(value):= NULL;
		next(value):= 	case
							next(time) = 0 | next(time) < 2: NULL;
							!invert  & next(time) != 6 : next(time) mod 2;
							TRUE : NULL;
						esac;			


MODULE port_c(time)
	VAR
		value: {0, 1, NULL};
	ASSIGN

MODULE port_d(time)
	VAR
		value: {0, 1, NULL};
	ASSIGN




MODULE finalAutomata(time, modoEntrada)
 VAR
 	cs : {q0q0, p0q0, p1q0}; 
 	ports : portsModule(time,modoEntrada); 
 ASSIGN
 	init(cs) := {q0q0};	
TRANS	
	( (cs = q0q0 &  ports.b.value = NULL & ports.c.value != NULL & ports.a.value = ports.c.value 
		& ports.d.value = NULL  & ports.c.value = 0 ) -> next(cs) = p0q0 ) &

	( (cs = q0q0 &  ports.a.value = NULL & ports.c.value != NULL & ports.b.value = ports.c.value 
		& ports.d.value = NULL  & ports.c.value = 0 ) -> next(cs) = p0q0 ) &	

	( (cs = q0q0 &  ports.b.value = NULL & ports.c.value != NULL & ports.a.value = ports.c.value 
		& ports.d.value = NULL  & ports.c.value = 1 ) -> next(cs) = p1q0 ) &

	( (cs = q0q0 &  ports.a.value = NULL & ports.c.value != NULL & ports.b.value = ports.c.value 
		& ports.d.value = NULL  & ports.c.value = 1 ) -> next(cs) = p1q0 ) &	

	( (cs = p0q0 & ports.c.value = NULL & ports.d.value = 0 ) -> next(cs) = q0q0 ) &

	( (cs = p0q0) -> ( (next(cs) != p1q0 ) ) ) &

	( (cs = p1q0 & ports.c.value = NULL & ports.d.value = 1 ) -> next(cs) = q0q0 ) &

	( (cs = p1q0) -> ( (next(cs) != p0q0 ) ) ) 

 

