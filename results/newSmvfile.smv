MODULE main
VAR
	time: 0..20;
	finalAutomata: finalAutomata(ports);
	ports: portsModule(time);
	x : 0..4;
	t : 0..20;
	A : 0..31;
	B : 0..31;
	C : 0..25;
	D : 0..7;
	ED : 0..7;
	DIV : 0..3;
	DIVC : 0..28;
	P : 0..3;
	y : 0..8;
	w : {NULL, batata};
	a : boolean;
	b : boolean;
	logand : boolean;
	lognot : boolean;
	logandT : boolean;
	logor : boolean;
	logIMP : boolean;
	logBIMP : boolean;
ASSIGN
	init(time) := 0;
	next(time) := case
		time < 20: time + 1;
		TRUE: time;
esac;
	init(x):= 2 + 2;
	next(x):= x;
	init(t):= 4 * 5;
	next(t):= t;
	init(A):= 4 * 7 + 3;
	next(A):= A;
	init(B):= 3 + 4 * 7;
	next(B):= B;
	init(C):= -3 + 4 * 7;
	next(C):= C;
	init(D):= 4 - -3;
	next(D):= D;
	init(ED):= 3 + 4 - 2 + 2;
	next(ED):= ED;
	init(DIV):= ED / 2;
	next(DIV):= DIV;
	init(DIVC):= 4 * 7 + 3 / 10;
	next(DIVC):= DIVC;
	init(P):= (4 * 7 + 3) / 10;
	next(P):= P;
	init(y):= 4 + x;
	next(y):= y;
	init(w):= NULL;
	next(w):= case 
		next(time) = 12 : batata;
		TRUE : w; 
	esac;
	init(a):= FALSE;
	next(a):= case 
		next(time) = 12 : TRUE;
		TRUE : a; 
	esac;
	init(b):= FALSE;
	next(b):= case 
		next(time) = 12 : FALSE;
		TRUE : b; 
	esac;
	init(logand):= FALSE;
	next(logand):= case 
		next(time) = 12 : next(a) & next(b);
		TRUE : logand; 
	esac;
	init(lognot):= FALSE;
	next(lognot):= case 
		next(time) = 12 : !next(b);
		TRUE : lognot; 
	esac;
	init(logandT):= FALSE;
	next(logandT):= case 
		next(time) = 12 : next(a) & !next(b);
		TRUE : logandT; 
	esac;
	init(logor):= FALSE;
	next(logor):= case 
		next(time) = 12 : next(a) | next(b);
		TRUE : logor; 
	esac;
	init(logIMP):= FALSE;
	next(logIMP):= case 
		next(time) = 12 : !next(a) -> !next(b);
		TRUE : logIMP; 
	esac;
	init(logBIMP):= FALSE;
	next(logBIMP):= case 
		next(time) = 12 : !next(a) <-> next(b);
		TRUE : logBIMP; 
	esac;

MODULE merger1(ports)
VAR
	cs: {q0};
TRANS
	((cs = q0 & ports.b.value = NULL & ports.d.value = NULL & ports.c.value != NULL & ports.a.value = ports.c.value & FALSE) -> next(cs) = q0) &
	((cs = q0 & ports.a.value = NULL & ports.d.value = NULL & ports.c.value != NULL & ports.b.value = ports.c.value & FALSE) -> next(cs) = q0);

MODULE fifo2(ports)
VAR
	cs: {q0,p0,p1};
ASSIGN
	init(cs) := {q0};
TRANS
	((cs = q0 & ports.a.value = NULL & ports.b.value = NULL & ports.d.value = NULL & ports.c.value = 0 & FALSE) -> next(cs) = p0) &
	((cs = q0 & ports.a.value = NULL & ports.b.value = NULL & ports.d.value = NULL & ports.c.value = 1 & FALSE) -> next(cs) = p1) &
	((cs = p0 & ports.a.value = NULL & ports.c.value = NULL & ports.b.value = NULL & ports.d.value = 0) -> next(cs) = q0) &
	((cs = p0) -> ((next(cs) != p1))) &
	((cs = p1 & ports.a.value = NULL & ports.c.value = NULL & ports.b.value = NULL & ports.d.value = 1) -> next(cs) = q0) &
	((cs = p1) -> ((next(cs) != p0)));

MODULE finalAutomata(ports)
VAR
	prod1: merger1(ports);
	prod2: fifo2(ports);
	cs: {q0q0,q0p0,q0p1};
ASSIGN
	init(cs) := {q0q0};
TRANS
	((cs = q0q0 & ports.b.value = NULL & ports.d.value = NULL & ports.c.value != NULL & ports.a.value = ports.c.value & ports.c.value = 0) -> next(cs) = q0p0) &
	((cs = q0q0 & ports.b.value = NULL & ports.d.value = NULL & ports.c.value != NULL & ports.a.value = ports.c.value & ports.c.value = 1) -> next(cs) = q0p1) &
	((cs = q0q0 & ports.a.value = NULL & ports.d.value = NULL & ports.c.value != NULL & ports.b.value = ports.c.value & ports.c.value = 0) -> next(cs) = q0p0) &
	((cs = q0q0 & ports.a.value = NULL & ports.d.value = NULL & ports.c.value != NULL & ports.b.value = ports.c.value & ports.c.value = 1) -> next(cs) = q0p1) &
	((cs = q0p0) -> ((next(cs) != q0p1))) &
	((cs = q0p1) -> ((next(cs) != q0p0)));
INVAR
	(((prod1.cs = q0) & (prod2.cs = q0)) <-> (cs = q0q0)) &
	(((prod1.cs = q0) & (prod2.cs = p0)) <-> (cs = q0p0)) &
	(((prod1.cs = q0) & (prod2.cs = p1)) <-> (cs = q0p1));

MODULE portsModule(time)
VAR 
ASSIGN

